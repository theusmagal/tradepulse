generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider  = "postgresql"
  url       = env("DATABASE_URL")
  directUrl = env("DIRECT_URL")
}

/* ---------- Enums ---------- */

enum Plan {
  PRO_MONTHLY
  PRO_ANNUAL
}

enum Side {
  BUY
  SELL
}

enum ApiKeyStatus {
  active
  revoked
}

/* ---------- Models ---------- */

model User {
  id                 String   @id @default(cuid())
  email              String   @unique
  password           String

  // Profile
  name               String?
  timezone           String   @default("UTC")

  // Billing / Subscription
  stripeCustomerId   String?  @unique
  stripeSubId        String?  @unique
  subscriptionStatus String?  // active | trialing | past_due | canceled | unpaid | incomplete
  plan               Plan?
  trialEndsAt        DateTime?

  // Timestamps
  createdAt          DateTime @default(now())
  updatedAt          DateTime @updatedAt

  // Relations
  subscriptions      BillingSubscription[]
  brokerAccounts     BrokerAccount[]
  apiKeys            ApiKey[]

  @@index([createdAt])
}

model BillingSubscription {
  id                   String   @id @default(cuid())
  userId               String
  stripeCustomerId     String
  stripeSubscriptionId String   @unique
  status               String
  currentPeriodEnd     DateTime?
  trialEnd             DateTime?
  createdAt            DateTime @default(now())
  updatedAt            DateTime @updatedAt

  user                 User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([stripeCustomerId])
  @@map("Subscription") // keeps the SAME table name in DB
}

model BrokerAccount {
  id           String   @id @default(cuid())
  userId       String
  broker       String   // e.g. "binance-futures", "binance-spot" later, "bybit-futures", etc.
  label        String?
  apiKeyEnc    String   // encrypted API key
  apiSecretEnc String   // encrypted API secret
  lastSyncAt   DateTime?
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  executions   Execution[]
  trades       Trade[]
  dailyMetrics DailyMetric[]

  @@index([userId])
  @@index([userId, broker])
}

model Execution {
  id              String        @id @default(cuid())
  brokerAccountId String
  symbol          String
  side            Side
  qty             Decimal       @db.Decimal(18, 6)
  price           Decimal       @db.Decimal(18, 6)
  fee             Decimal       @db.Decimal(18, 6)

  // Realized PnL per execution (from CSV / API)
  realizedPnl     Decimal?      @db.Decimal(18, 6)

  execTime        DateTime
  tradeId         String?
  createdAt       DateTime      @default(now())
  updatedAt       DateTime      @updatedAt

  brokerAccount   BrokerAccount @relation(fields: [brokerAccountId], references: [id], onDelete: Cascade)

  @@index([brokerAccountId, execTime])
  @@index([brokerAccountId, symbol, execTime])

  // prevents importing the same execution twice
  @@unique([brokerAccountId, symbol, side, qty, price, execTime, fee, realizedPnl])
}

model Trade {
  id              String        @id @default(cuid())
  brokerAccountId String
  symbol          String
  side            Side
  openTime        DateTime
  closeTime       DateTime
  qty             Decimal       @db.Decimal(18, 6)
  avgEntry        Decimal       @db.Decimal(18, 6)
  avgExit         Decimal       @db.Decimal(18, 6)
  grossPnl        Decimal       @db.Decimal(18, 2)
  netPnl          Decimal       @db.Decimal(18, 2)
  fees            Decimal       @db.Decimal(18, 2)
  createdAt       DateTime      @default(now())
  updatedAt       DateTime      @updatedAt

  brokerAccount   BrokerAccount @relation(fields: [brokerAccountId], references: [id], onDelete: Cascade)

  @@index([brokerAccountId, closeTime])
  @@index([symbol])

  // NEW: lets us safely use createMany(..., skipDuplicates: true)
  @@unique([brokerAccountId, symbol, side, closeTime, qty, netPnl])
}

model DailyMetric {
  id              String        @id @default(cuid())
  brokerAccountId String
  date            DateTime
  trades          Int
  wins            Int
  losses          Int
  winRate         Decimal       @db.Decimal(6, 4)
  profitFactor    Decimal       @db.Decimal(10, 4)
  netPnl          Decimal       @db.Decimal(18, 2)
  createdAt       DateTime      @default(now())
  updatedAt       DateTime      @updatedAt

  brokerAccount   BrokerAccount @relation(fields: [brokerAccountId], references: [id], onDelete: Cascade)

  @@unique([brokerAccountId, date])
  @@index([brokerAccountId, date])
}

model ApiKey {
  id        String        @id @default(cuid())
  userId    String
  provider  String        // e.g. "binance-futures" later if you need app-wide keys
  label     String?
  keyLast4  String
  encApiKey String
  encSecret String

  status    ApiKeyStatus  @default(active)
  createdAt DateTime      @default(now())
  updatedAt DateTime      @updatedAt

  User      User          @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId, provider])
  @@index([userId, provider, status])
}
